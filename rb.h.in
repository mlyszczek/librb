/** =========================================================================
 * @brief     ring buffer message queue implementation
 * @author    Michał Łyszczek (michal.lyszczek@bofc.pl)
 * @date      2025-10-18
 * @copyright Copyright by Michał Łyszczek
 * @license   BSD-2-Clause
 * @version   9999
 * @homepage  https://librb.bofc.pl/
 * @manuals   https://librb.bofc.pl/rb_overview.7.html
 * ========================================================================== */
#ifndef LIBRB_H
#define LIBRB_H 1

#define ENABLE_THREADS @ENABLE_THREADS@

#include <stdatomic.h>
#include <stddef.h>

#if ENABLE_THREADS
#   include <pthread.h>
#   include <semaphore.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

enum rb_flags
{
	/** ======================================================================
	 * Read data from ring buffer but do not advance #tail pointer, so data
	 * will not be removed from ring buffer. Consequent read from ring buffer
	 * will get you same data */
	rb_peek        = 1 <<  0,

	/** ======================================================================
	 * Create non-blocking ring buffer, meaning no call will ever block
	 * executing thread. You can pass it to #rb_new or #rb_init.
	 *
	 * This makes sense to use only when ring buffer is in multi-thread mode */
	rb_nonblock    = 1 <<  1,

	/** ======================================================================
	 * Read or write from/to ring buffer but do not block if buffer is empty
	 * or full. Works for single #rb_send/#rb_recv call.
	 *
	 * This makes sense to use only when ring buffer is in multi-thread mode */
	rb_dontwait    = 1 <<  2,

	/** ======================================================================
	 * If ENABLE_THREADS is defined, it will put ring buffer into
	 * multi-threaded mode. This will allow you to call all rb_read/write
	 * functions with multiple threads. These calls can also be optionally
	 * made into blocking calls, so you can wait for data in rb_read()
	 * without polling */
	rb_multithread = 1 <<  3,

	/** ======================================================================
	 * If this flag is passed, count will be rounded up to the nearest
	 * power of 2, this may eat up a lot of unused memory if enabled.
	 *
	 * This only makes sense to use when you are creating ring buffer with
	 * #rb_new() function */
	rb_round_count = 1 <<  4,

	/** ======================================================================
	 * If ring buffer is created with this flag, and there is not enough
	 * space on the buffer, librb will grow the #buffer by factor of 2.
	 * This will result in #rb_write() to never fail due to lack of space
	 * in ring buffer - unless realloc() fails to allocate more memory.
	 *
	 * This only makes sense to use when you are creating ring buffer with
	 * #rb_new() function */
	rb_growable    = 1 <<  5,

	/** ======================================================================
	 * Create dynamic ring buffer. Normally ring buffer holds object of
	 * static object size, like bytes (object_size == 1), or structs
	 * (object_size == sizeof(struct your_struct). Dynamic ring buffer
	 * may contain different structs, or null terminated strings, that can
	 * be fully retrieved with single #rb_read() call */
	rb_dynamic     = 1 <<  6,

	/** ======================================================================
	 * Used with commit/claim API to NOT lock buffer again after committing
	 * data to the buffer. May be useful when you want need to copy multiple
	 * objects in multiple calls before notifying other threads. Useful only
	 * in multi-thread mode.
	 */
	rb_continue    = 1 <<  7,
};

#if ENABLE_THREADS
typedef atomic_size_t rb_size_t;
#else
typedef size_t rb_size_t;
#endif

struct rb
{
	rb_size_t        head;        /* pointer to buffer's head */
	rb_size_t        tail;        /* pointer to buffer's tail */
	rb_size_t        count;       /* maximum number of elements in buffer */
	rb_size_t        max_count;   /* hard limit count, when rb_growable is set */
	rb_size_t        object_size; /* size of a single object in buffer */
	enum rb_flags    flags;       /* flags used with buffer */
	unsigned char   *buffer;      /* pointer to ring buffer in memory */

#if ENABLE_THREADS
	pthread_mutex_t  read_lock;   /* global lock for reading from rb */
	pthread_mutex_t  write_lock;  /* global lock for writing to rb */
	sem_t            read_sem;    /* semaphore for read signaling */
	sem_t            write_sem;   /* semaphore for write signaling */
	atomic_int       force_exit;  /* holds reason for stopping functions */
#endif
};

#define rb_array_size(a) (sizeof(a)/sizeof(*(a)))

/** =========================================================================
 * Initializes ring buffer and allocates all necessary resources.
 *
 * Newly created rb will returned as a pointer. In case of an function
 * error, NULL will be returned
 *
 * @param count number of elements that buffer can hold
 * @param object_size size, in bytes, of a single object
 * @param flags flags to create buffer with
 *
 * @return 0 on success, otherwise -1 is returned
 * @exception EINVAL count is not a power of 2 value
 * @exception EINVAL rb_dynamic flag passed, but object_size is not valid
 *            integer size
 * ========================================================================== */
struct rb *rb_new(size_t count, size_t object_size, enum rb_flags flags);

/** =========================================================================
 * Initializes new ring buffer object but does not use dynamic memory
 * allocation, you must instead provide pointers to struct rb, and
 * buffer where data will be stored
 *
 * @param rb ring buffer to initialize
 * @param buf memory buffer where data shall be stored
 * @param count number of elements that buffer can hold
 * @param object_size size, in bytes, of a single object
 * @param flags flags to create buffer with
 *
 * @return 0 on success, otherwise -1 is returned
 * 
 * @exception EINVAL count is not a power of 2 value
 * @exception EINVAL rb_round_count flag passed
 * @exception EINVAL rb_growable flag passed
 * @exception EINVAL rb or buf is NULL
 * @exception EINVAL rb_dynamic flag passed, but object_size is not valid
 *            integer size
 * ========================================================================== */
int rb_init(struct rb *rb, void *buf, size_t count, size_t object_size,
	enum rb_flags flags);

/** =========================================================================
 * Set hard limit for ring buffer count, when #rb is #rb_growable
 *
 * @param rb ring buffer object
 * @param count hard limit for count when growing buffer
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_set_hard_max_count(struct rb *rb, size_t count);

/** =========================================================================
 * Reads maximum #count elements from rb and stores them into buffer.
 *
 * If there is not enough data in ring buffer, function will read whatever
 * is in the ring buffer and return with only elements read.
 *
 * If multi-threading is enabled, and operation is blocking, function will
 * block until at least 1 element has been read.
 *
 * If #rb is growable and write thread wants to grow #rb, it's possible
 * for #rb_read() to return early with -1/EAGAIN.
 *
 * @param rb ring buffer object
 * @param buffer location where data from rb will be stored
 * @param count requested number of data from rb
 *
 * @return Number of objects copied to #buffer
 * @return -1 when no data could be copied to #buffer (rb is empty)
 *
 * @exception EAGAIN ring buffer is empty, nothing copied to #buffer
 * @exception EINVAL invalid parameter passed
 * @exception ENOBUFS #rb is #rb_dynamic and there is data on #rb, but
 *            #buffer is not big enough to hold whole message
 * ========================================================================== */
long rb_read(struct rb *rb, void *buffer, size_t count);

/** =========================================================================
 * Same as rb_read but also accepts #flags
 *
 * - rb_peek: do normal read operation, but do not remove read data from
 *   ring buffer, calling rb_recv() with this flag multiple times will yield
 *   same results (provided that no new data is copied to ring buffer).
 *   Peeking is always non-blocking operation regardless of other settings,
 *   if it cannot immediately read data it will return -1/EAGAIN
 * - rb_dontwait: don't ever block a call, return with -1/EAGAIN if there is
 *   no data to read
 *
 * @param rb ring buffer object
 * @param buffer location where data from rb will be stored
 * @param count requested number of data from rb
 * @param flags single call flags
 *
 * @return Number of objects copied to #buffer
 * @return -1 on error
 *
 * @exception EAGAIN ring buffer is empty, nothing copied to #buffer
 * @exception EINVAL invalid parameter passed
 * @exception ENOBUFS #rb is #rb_dynamic and there is data on #rb, but
 *            #buffer is not big enough to hold whole message
 * ========================================================================== */
long rb_recv(struct rb *rb, void *buffer, size_t count, enum rb_flags flags);

/** =========================================================================
 * Function writes maximum count of data into ring buffer from buffer
 *
 * If there is not enough space to store all data from buffer, function will
 * store as many as it can, and will return count of objects stored into
 * ring buffer. If buffer is full, function returns -1 and EAGAIN error.
 *
 * If #rb is blocking, function will block until all #count data is written,
 * or there is an error.
 *
 * Works same way as rb_send() with flags set to 0.
 *
 * @param rb ring buffer object
 * @param buffer location of data to put into rb
 * @param count number of elements to put on the rb
 *
 * @return On success function will return number of objects copied to #buffer
 * @return On error -1 is returned
 *
 * @exception EAGAIN ring buffer is full, cannot copy anything to it
 * @exception ENOMEM #rb is growable, but we failed to allocate more memory
 * @exception EMSGSIZE #rb is dynamic and #count is too large. Increase
 *            object_size in #rb creation.
 * @exception ECANCELED rb_stop() has been called, and there was no data
 *            written to rb, returned only when #rb it multi-threaded
 * ========================================================================== */
long rb_write(struct rb *rb, const void *buffer, size_t count);

/** =========================================================================
 * Same as #rb_write but also accepts flags.
 *
 * - rb_dontwait when flag is passed, function will never block execution
 *   thread
 *
 * @param rb ring buffer object
 * @param buffer location of data to put into rb
 * @param count number of elements to put on the rb
 * @param flags single call flag
 *
 * @return On success function will return number of objects copied to #buffer
 * @return On error -1 is returned
 *
 * @exception EAGAIN ring buffer is full, cannot copy anything to it
 * @exception ENOMEM #rb is growable, but we failed to allocate more memory
 * @exception EMSGSIZE #rb is dynamic and #count is too large. Increase
 *            object_size in #rb creation.
 * @exception ECANCELED rb_stop() has been called, and there was no data
 *            written to rb, returned only when #rb it multi-threaded
 * ========================================================================== */
long rb_send(struct rb *rb, const void *buffer, size_t count,
	enum rb_flags flags);

/** =========================================================================
 * Peek at size of next message in the #rb. This only makes sense when #rb
 * is dynamic
 *
 * @param rb ring buffer object
 *
 * @return size of next message in the #rb
 * @return -1 on error
 *
 * @exception EINVAL #rb is NULL, or #rb is not #rb_dynamic
 * ========================================================================== */
long rb_peek_size(struct rb *rb);

/** =========================================================================
 * Claims ring buffer for reading.
 *
 * In return you will get pointer to a #buffer. You can directly read from it
 * starting at offset 0. #count will tell you how big #buffer is. Do not
 * even think about reading more elements than #count. If you are close to
 * memory wrap, #count may be very small, fully read the #buffer and next
 * call will give you more memory to read.
 *
 * #object_size defines size of a single object that is held on ring buffer.
 * You should read from a #buffer in increments of #object_size bytes.
 *
 * If multi-thread #rb is used, function will block like #rb_read until
 * data is available on #rb. After function finishes, you will be the owner
 * of #rb->rlock mutex, so no one will interfere with your reading.
 *
 * @note that #count does not describe #buffer size in bytes, but in "elements".
 *       #buffer size in bytes is #count * #object_size
 * @note remember to call #rb_read_commit() once you are done
 *
 * @param rb ring buffer object
 * @param buffer location from where data can be read
 * @param count max number of elements that can be read from #buffer
 * @param object_size size of single object #rb holds (in bytes)
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_read_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size);

/** =========================================================================
 * Claims ring buffer for reading.
 *
 * In return you will get pointer to a #buffer. You can directly read from it
 * starting at offset 0. #count will tell you how big #buffer is. Do not
 * even think about reading more elements than #count. If you are close to
 * memory wrap, #count may be very small, fully read the #buffer and next
 * call will give you more memory to read.
 *
 * #object_size defines size of a single object that is held on ring buffer.
 * You should read from a #buffer in increments of #object_size bytes.
 *
 * You can specify #flags as with #rb_recv() plus additionally:
 * - rb_continue: get buffer but do not try to lock the mutex, you must first
 *   call rb_recv_commit() with #rb_continue flag or else you will hang in
 *   double lock case. This flag will do nothing for single thread operation.
 *
 * If multi-thread #rb is used, function will block like #rb_read until
 * data is available on #rb. After function finishes, you will be the owner
 * of #rb->rlock mutex, so no one will interfere with your reading.
 *
 * @note that #count does not describe #buffer size in bytes, but in "elements".
 *       #buffer size in bytes is #count * #object_size
 * @note remember to call #rb_read_commit() once you are done
 *
 * @param rb ring buffer object
 * @param buffer location from where data can be read
 * @param count max number of elements that can be read from #buffer
 * @param object_size size of single object #rb holds (in bytes)
 * @param flags operation flags
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_recv_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size, enum rb_flags flags);

/** =========================================================================
 * Commits data read from #rb in #rb_read_claim. You just have to
 * specify number of elements actually read from #rb in claim call.
 *
 * In multi-thread environment, this will release read mutex and threads
 * blocked in write will be woken up. It's ok to pass 0 as #count.
 *
 * @param rb ring object to commit to
 * @param count number of elements read from ring buffer after claiming it
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_read_commit(struct rb *rb, size_t count);

/** =========================================================================
 * Commits data read from #rb in #rb_read_claim. You just have to
 * specify number of elements actually read from #rb in claim call.
 *
 * In multi-thread environment, this will release read mutex and threads
 * blocked in write will be woken up. It's ok to pass 0 as #count.
 *
 * You can specify following flags:
 * - rb_continue: commit data to the buffer but DO NOT unlock mutex or
 *   notify other threads yet. You will still hold the lock. When getting
 *   more buffer data you must next call rb_recv_claim() with #rb_continue
 *   flag as well. Calling this function once again but without #rb_continue
 *   the second time will just release the lock. This flag will do nothing
 *   in single thread mode
 *
 * @param rb ring object to commit to
 * @param count number of elements read from ring buffer after claiming it
 * @param flags operation flags
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_recv_commit(struct rb *rb, size_t count, enum rb_flags flags);

/** =========================================================================
 * Claims ring buffer for writing.
 *
 * In return you will get pointer to a #buffer. You can directly write to it
 * starting from offset 0. #count will tell you how big #buffer is. Do not
 * even think about writing more elements than #count. If you are close to
 * memory wrap, #count may be very small, fill the #buffer and next call will
 * give you more memory.
 *
 * #object_size defines size of a single object that is held on ring buffer.
 * You should write to a buffer in increments of #object_size bytes.
 *
 * If multi-thread #rb is used, function will block like #rb_send until
 * space is available on #rb. After function finishes, you will be the owner
 * of #rb->wlock mutex, so no one will interfere with your writing.
 *
 * @note that #count does not describe #buffer size in bytes, but in "elements".
 *       #buffer size in bytes is #count * #object_size
 * @note remember to call #rb_write_commit() once you are done
 *
 * @param rb ring buffer object
 * @param buffer location where data should be copied to
 * @param count max number of elements that can be copied to #buffer
 * @param object_size size of single object #rb holds (in bytes)
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_write_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size);

/** =========================================================================
 * Claims ring buffer for writing.
 *
 * In return you will get pointer to a #buffer. You can directly write to it
 * starting from offset 0. #count will tell you how big #buffer is. Do not
 * even think about writing more elements than #count. If you are close to
 * memory wrap, #count may be very small, fill the #buffer and next call will
 * give you more memory.
 *
 * #object_size defines size of a single object that is held on ring buffer.
 * You should write to a buffer in increments of #object_size bytes.
 *
 * You can specify #flags as with #rb_send() plus additionally:
 * - rb_continue: get buffer but do not try to lock the mutex, you must first
 *   call rb_send_commit() with #rb_continue flag or else you will hang in
 *   double lock case. This flag will do nothing for single thread operation.
 *
 * If multi-thread #rb is used, function will block like #rb_send until
 * space is available on #rb. After function finishes, you will be the owner
 * of #rb->wlock mutex, so no one will interfere with your writing.
 *
 * @note that #count does not describe #buffer size in bytes, but in "elements".
 *       #buffer size in bytes is #count * #object_size
 * @note remember to call #rb_write_commit() once you are done
 *
 * @param rb ring buffer object
 * @param buffer location where data should be copied to
 * @param count max number of elements that can be copied to #buffer
 * @param object_size size of single object #rb holds (in bytes)
 * @param flags operation flags
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_send_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size, enum rb_flags flags);

/** =========================================================================
 * Commits data written to #rb in #rb_write_claim buffer. You just have to
 * specify number of elements actually written to #rb in claim call.
 *
 * In multi-thread environment, this will release write mutex and threads
 * blocked in read will be woken up. It's ok to pass 0 as #count.
 *
 * @param rb ring object to commit to
 * @param count number of elements written to ring buffer after claiming it
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_write_commit(struct rb *rb, size_t count);

/** =========================================================================
 * Commits data written to #rb in #rb_write_claim buffer. You just have to
 * specify number of elements actually written to #rb in claim call.
 *
 * In multi-thread environment, this will release write mutex and threads
 * blocked in read will be woken up. It's ok to pass 0 as #count.
 *
 * You can specify following flags:
 * - rb_continue: commit data to the buffer but DO NOT unlock mutex or
 *   notify other threads yet. You will still hold the lock. When getting
 *   more buffer data you must next call rb_recv_claim() with #rb_continue
 *   flag as well. Calling this function once again but without #rb_continue
 *   the second time will just release the lock. This flag will do nothing
 *   in single thread mode
 *
 * @param rb ring object to commit to
 * @param count number of elements written to ring buffer after claiming it
 * @param flags operation flags
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_send_commit(struct rb *rb, size_t count, enum rb_flags flags);

/** =========================================================================
 * Shortcut function to perform claim immediately followed by commit with
 * #rb_continue flag. In short, this will commit buffer and immediately take
 * new one without releasing the lock.
 *
 * @param rb ring buffer object
 * @param buffer location where data can be written to will be stored here
 * @param count in/out param, on input defines how many bytes you are
 *        committing to buffer (like in #rb_write_commit), and as output, it
 *        will hold number of elements that can be written to #buffer
 * @param object_size size of single object #rb holds (in bytes)
 * @param flags operation flags
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_send_commit_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size, enum rb_flags flags);

/** =========================================================================
 * Shortcut function to perform claim immediately followed by commit with
 * #rb_continue flag. In short, this will commit buffer and immediately take
 * new one without releasing the lock.
 *
 * @param rb ring buffer object
 * @param buffer location where data can be written to will be stored here
 * @param count in/out param, on input defines how many bytes you are
 *        committing to buffer (like in #rb_write_commit), and as output, it
 *        will hold number of elements that can be written to #buffer
 * @param object_size size of single object #rb holds (in bytes)
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_write_commit_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size);

/** =========================================================================
 * Shortcut function to perform claim immediately followed by commit with
 * #rb_continue flag. In short, this will commit buffer and immediately take
 * new one without releasing the lock.
 *
 * @param rb ring buffer object
 * @param buffer location from where data can be read will be stored here
 * @param count in/out param, on input defines how many bytes you are
 *        committing to buffer (like in #rb_read_commit), and as output, it
 *        will hold number of elements that can be read from #buffer
 * @param object_size size of single object #rb holds (in bytes)
 * @param flags operation flags
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_recv_commit_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size, enum rb_flags flags);

/** =========================================================================
 * Shortcut function to perform claim immediately followed by commit with
 * #rb_continue flag. In short, this will commit buffer and immediately take
 * new one without releasing the lock.
 *
 * @param rb ring buffer object
 * @param buffer location from where data can be read will be stored here
 * @param count in/out param, on input defines how many bytes you are
 *        committing to buffer (like in #rb_read_commit), and as output, it
 *        will hold number of elements that can be read from #buffer
 * @param object_size size of single object #rb holds (in bytes)
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_read_commit_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size);

/** =========================================================================
 * Clears all data in the buffer
 *
 * Normally function do quick clean - only sets tail = head variable to
 * indicate buffer is free. If #clear is set to 1, function will also zero
 * out all ring buffer memory - in case you want to remove some confidential
 * data from memory. On multi-thread this will wake up threads blocked on
 * write, and these functions may return error during operation.
 *
 * @param rb ring buffer object
 * @param clear if set to 1, will also clear memory
 *
 * @return 0 on success, otherwise -1 is returned
 * @exception EINVAL invalid ring buffer object passed
 * ========================================================================== */
int rb_clear(struct rb *rb, int clear);

/** =========================================================================
 * Same as #rb_cleanup() but for objects created with #rb_new() instead
 *
 * @param rb ring buffer object to destroy
 *
 * @return 0 on success, otherwise -1 is returned
 * @exception EINVAL invalid ring buffer object passed
 * ========================================================================== */
int rb_destroy(struct rb *rb);

/** =========================================================================
 * Clean up stack allocated ring buffer. Should only be called when #rb has
 * been created with #rb_init() function. If you have multi-threaded #rb,
 * you must first make sure no other thread is using #rb object. You can
 * wake up locked threads with #rb_stop() function.
 *
 * @param rb ring buffer to cleanup
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
int rb_cleanup(struct rb *rb);

/** =========================================================================
 * Function that discards data from tail of buffer. This works just like
 * rb_reads function, but is way faster as there is no copying involved
 *
 * @param rb ring buffer object
 * @param count number of elements to discard
 *
 * @return 0 on success, otherwise -1 is returned
 * ========================================================================== */
long rb_discard(struct rb *rb, size_t count);

/** =========================================================================
 * Returns number of elements in buffer
 *
 * @param rb ring buffer object
 *
 * @return on success will return number of elements in buffer
 * @return on error -1 is returned with errno
 * @exception EINVAL invalid #rb object passed
 * ========================================================================== */
long rb_count(struct rb *rb);

/** =========================================================================
 * Returns number of free elements in buffer
 *
 * @param rb ring buffer object
 *
 * @return on success will return number of free elements in buffer
 * @return on error -1 is returned with errno
 * @exception EINVAL invalid #rb object passed
 * ========================================================================== */
long rb_space(struct rb *rb);

/** =========================================================================
 * Makes all rb_read/write and family functions to wake up and return with
 * error. You can call this function as many times as you want to make sure
 * all your threads are unlocked and not using #rb anymore before you destroy
 * the ring buffer.
 *
 * It only makes sense to call this when #rb is in multi-threaded mode
 *
 * @param rb ring buffer to finish
 *
 * @return 0 on success, otherwise -1 is returned
 * 
 * @exception ENOSYS #rb has been compiled without multi-thread support
 * @exception EINVAL #rb is invalid or is not a in a multi-thread mode
 * ========================================================================== */
int rb_stop(struct rb *rb);

#ifdef __cplusplus
}
#endif

#endif
