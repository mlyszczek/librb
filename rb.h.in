/* ==========================================================================
    Licensed under BSD 2clause license. See LICENSE file for more information
    Author: Michał Łyszczek <michal.lyszczek@bofc.pl>
   ========================================================================== */
#ifndef LIBRB_H
#define LIBRB_H 1

#define ENABLE_THREADS @ENABLE_THREADS@

#include <stdatomic.h>
#include <stddef.h>

#if ENABLE_THREADS
#   include <pthread.h>
#   include <semaphore.h>
#endif

enum rb_flags
{
	/** ======================================================================
	 * Read data from ring buffer but do not advance #tail pointer, so data
	 * will not be removed from ring buffer. Consequent read from ring buffer
	 * will get you same data */
	rb_peek        = 1 <<  0,

	/** ======================================================================
	 * Create non-blocking ring buffer, meaning no call will ever block
	 * executing thread. You can pass it to #rb_new or #rb_init.
	 *
	 * This makes sense to use only when ring buffer is in multi-thread mode */
	rb_nonblock    = 1 <<  1,

	/** ======================================================================
	 * Read or write from/to ring buffer but do not block if buffer is empty
	 * or full. Works for single #rb_send/#rb_recv call.
	 *
	 * This makes sense to use only when ring buffer is in multi-thread mode */
	rb_dontwait    = 1 <<  2,

	/** ======================================================================
	 * If ENABLE_THREADS is defined, it will put ring buffer into
	 * multi-threaded mode. This will allow you to call all rb_read/write
	 * functions with multiple threads. These calls can also be optionally
	 * made into blocking calls, so you can wait for data in rb_read()
	 * without polling */
	rb_multithread = 1 <<  3,

	/** ======================================================================
	 * If this flag is passed, count will be rounded up to the nearest
	 * power of 2, this may eat up a lot of unused memory if enabled.
	 *
	 * This only makes sense to use when you are creating ring buffer with
	 * #rb_new() function */
	rb_round_count = 1 <<  4,

	/** ======================================================================
	 * If ring buffer is created with this flag, and there is not enough
	 * space on the buffer, librb will grow the #buffer by factor of 2.
	 * This will result in #rb_write() to never fail due to lack of space
	 * in ring buffer - unless realloc() fails to allocate more memory.
	 *
	 * This only makes sense to use when you are creating ring buffer with
	 * #rb_new() function */
	rb_growable    = 1 <<  5,

	/** ======================================================================
	 * Create dynamic ring buffer. Normally ring buffer holds object of
	 * static object size, like bytes (object_size == 1), or structs
	 * (object_size == sizeof(struct your_struct). Dynamic ring buffer
	 * may contain different structs, or null terminated strings, that can
	 * be fully retrieved with single #rb_read() call */
	rb_dynamic     = 1 <<  6,
};

struct rb
{
	atomic_size_t    head;        /* pointer to buffer's head */
	atomic_size_t    tail;        /* pointer to buffer's tail */
	atomic_size_t    count;       /* maximum number of elements in buffer */
	atomic_size_t    object_size; /* size of a single object in buffer */
	enum rb_flags    flags;       /* flags used with buffer */
	unsigned char   *buffer;      /* pointer to ring buffer in memory */

#if ENABLE_THREADS
	pthread_mutex_t  lock;        /* mutex for concurrent access */
	pthread_mutex_t  rlock;       /* global lock for reading from rb */
	pthread_mutex_t  wlock;       /* global lock for writing to rb */
	sem_t            read_sem;    /* semaphore for read signaling */
	sem_t            write_sem;   /* semaphore for write signaling */
	atomic_int       force_exit;  /* holds reason for stopping functions */
#endif
};

struct rb *rb_new(size_t count, size_t object_size, enum rb_flags flags);
int rb_init(struct rb *rb, void *buf, size_t count, size_t object_size,
	enum rb_flags flags);
long rb_read(struct rb *rb, void *buffer, size_t count);
long rb_recv(struct rb *rb, void *buffer, size_t count, enum rb_flags flags);
long rb_write(struct rb *rb, const void *buffer, size_t count);
long rb_send(struct rb *rb, const void *buffer, size_t count,
	enum rb_flags flags);
long rb_peek_size(struct rb *rb);

long rb_read_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size, enum rb_flags flags);
long rb_read_commit(struct rb *rb, size_t count);
long rb_write_claim(struct rb *rb, void **buffer, size_t *count,
	size_t *object_size, enum rb_flags flags);
long rb_write_commit(struct rb *rb, size_t count);

int rb_clear(struct rb *rb, int clear);
int rb_destroy(struct rb *rb);
int rb_cleanup(struct rb *rb);
long rb_discard(struct rb *rb, size_t count);
long rb_count(struct rb *rb);
long rb_space(struct rb *rb);
int rb_stop(struct rb *rb);

#endif
