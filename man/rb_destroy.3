.TH "rb_destroy" "3" "24 July 2017 (v2.0.0)" "bofc.pl"

.SH NAME
\fBrb_destroy\fR \fBrb_stop\fR - functions to stop any locked threads in rb
functions and free resources allocated by \fBrb_new()\fR

.SH SYNOPSIS

.sh
.BI "int rb_stop(struct rb *" rb ");"
.br
.BI "int rb_destroy(struct rb *" rb ");"

.SH DESCRIPTION
Function \fBrb_stop\fR(3) spawns thread (and then exits) that forces any locked
thread to exit from \fBrb_read\fR(3)or \fBrb_send\fR(3). Also after this
function is called, any call to \fBrb_read\fR(3) or \fBrb_send\fR(3) will result
in error.

Function \fBrb_destroy\fR(3) simply frees all resources allocated by
\fBrb_new\fR(3). If \fBrb_stop\fR(3) was called before, function will stop
spawned thread. After calling this, \fIrb\fR that was freed, cannot be used
anymore without calling \fBrb_new()\fR first. Passing same \fIrb\fR object
twice, will result in segmentation fault.

.SH NOTES
Due to nature of \fBpthread\fR, you must be sure that no threads are calling
any functions rom \fBlibrb\fR before calling \fBrb_destroy\fR(3). Failing to do
so, will lead to deadlocks or crashes sooner or later.

If you cannot stop threads by yourself before calling \fBrb_destroy\fR(3), you
can use \fBrb_stop\fR(3) function, to force all threads to exit, then join them,
and after that destroy \fIrb\fR object. Look at below example.

.nf
void *consumer(void *arg)
{
    struct rb *rb = arg;
    int v, e;
    if (rb_read(rb, &v, 1) != 0)
    {
        if (errno == ECANCELED)
        {
            /* function was forced to exit, we should stop thread
             * or at least make sure we don't access rb_* functions
             * anymore
             /

             return NULL;
        }
    }
    /* more code */
}

void foo(void)
{
    /* some code */
    for (int i = 0; i != 10; ++i)
    {
        pthread_create(&consumers[i], NULL, consumer, rb);
    }

    /* wait for some event */
    /* force all consumer threads to exit even if they are locked
     * in some conditional variables
     */
    rb_stop(rb);

    for (i = 0; i != 10; ++i)
    {
        /* make sure all consumer threads stopped, and none will access
         * any rb_* functions
         /
        pthread_join(consumers[i], NULL);
    }

    /* now it is safe to call rb_destroy function */
    rb_destroy(rb);
}

.SH RETURN VALUES
Function will return 0 when all resources were freed, otherwise -1 is returned.
If function returns -1 \fIrb\fR object is not modified.

.SH ERRORS

.TP
.B EINVAL
Passed \fIrb\fR is invalid (null)

.SH SEE ALSO
.BR rb_overview (7),
.BR rb_new (3),
.BR rb_read (3),
.BR rb_recv (3),
.BR rb_write (3),
.BR rb_send (3),
.BR rb_clear (3),
.BR rb_count (3),
.BR rb_space (3),
.BR rb_version (3)
