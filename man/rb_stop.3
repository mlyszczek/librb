.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "RB_STOP" "3" "Sep 09, 2025" "" "librb"
.SH NAME
.sp
\fI\%rb_destroy(3)\fP, \fI\%rb_cleanup(3)\fP, \fI\%rb_stop(3)\fP \- stop, destroy and cleanup ring buffer
.SH SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.EX
#include <rb.h>

int rb_destroy(struct rb *rb);
int rb_cleanup(struct rb *rb);
.EE
.UNINDENT
.UNINDENT
.SH DESCRIPTION
.sp
\fI\%rb_destroy(3)\fP will \fBfree()\fP up memory allocated by \fI\%rb_new(3)\fP\&.
.sp
\fI\%rb_cleanup(3)\fP does nothing unless multi\-thread is enabled. You still should call
this in every scenario in case you switch \fI\%rb_init(3)\fP to multi\-thread, or library
will get updated with some cleaning code in the future.
.sp
If \fIrb\fP is multi\-thread enabled, functions will destroy thread related objects
like semaphores and mutexes.
.sp
Cleanup functions are safe to call only when no other thread is using \fIrb\fP
object. This may get tricky when you want destroy ring buffer but some pesky
thread in blocked in read or write operation. \fI\%rb_stop(3)\fP will wake all those
threads, and read/write functions will start returning with \fBECANCELED\fP
error. You can then join your threads and safely call cleanup function.
.SH RETURN VALUE
.sp
0 on success or \-1 on errors.
.SH ERROR
.INDENT 0.0
.TP
.B EINVAL
\fIrb\fP is NULL
.UNINDENT
.SH EXAMPLE
.sp
Stop threads before destroying ring buffer
.INDENT 0.0
.INDENT 3.5
.sp
.EX
/* consumers thread */
void *consumer(void *arg) {
    for (;;) {
        if (rb_read(rb, buf, sizeof(buf)) == \-1 && errno == ECANCELED)
            /* return from the thread */
            return NULL;
    }
 }

/* producers thread */
void *producer(void *arg) {
    for (;;) {
        if (rb_write(rb, buf, sizeof(buf)) == \-1 && errno == ECANCELED)
            /* return from the thread */
            return NULL;
    }
 }

 /* main thread */
 void main_loop(void) {
     pthread_t cons, prod;

     pthread_create(&cons, NULL, consumer, rb);
     pthread_create(&prod, NULL, consumer, rb);

     wait_for_exit_signal();

     /* wake consumer and producer threads, rb_ functions will start
      * returning ECANCELED errors, and threads will exit */
     rb_stop(rb);

     pthread_join(cons);
     pthread_join(prod);

     /* it\(aqs now safe to destroy buffer */
     rb_destroy(rb);
 }
.EE
.UNINDENT
.UNINDENT
.SH SEE ALSO
.sp
\fI\%rb_new(3)\fP, \fI\%rb_init(3)\fP, \fI\%rb_destroy(3)\fP, \fI\%rb_cleanup(3)\fP, \fI\%rb_write(3)\fP, \fI\%rb_send(3)\fP,
\fI\%rb_read(3)\fP, \fI\%rb_recv(3)\fP, \fI\%rb_read_claim(3)\fP, \fI\%rb_read_commit(3)\fP, \fI\%rb_write_claim(3)\fP,
\fI\%rb_write_commit(3)\fP, \fI\%rb_clear(3)\fP, \fI\%rb_discard(3)\fP, \fI\%rb_count(3)\fP, \fI\%rb_space(3)\fP,
\fI\%rb_stop(3)\fP, \fI\%rb_peek_size(3)\fP, \fI\%rb_set_hard_max_count(3)\fP
.SH AUTHOR
Michał Łyszczek <michal.lyszczek@bofc.pl>
.SH COPYRIGHT
2025, Michał Łyszczek
.\" Generated by docutils manpage writer.
.
