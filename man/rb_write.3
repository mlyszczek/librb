.TH "rb_write" "3" " 9 February 2018 (v1.0.0)" "bofc.pl"
.SH NAME
.PP
.BR rb_write ,
.BR rb_send ,
.BR rb_posix_write ,
.B rb_posix_send
- functions to put data on ring buffer
.SH SYNOPSIS
.PP
.BI "#include <librb.h>"
.PP
.BI "long rb_write(struct rb *" rb ", const void *" buffer ", \
size_t " count ");"
.br
.BI "long rb_send(struct rb *" rb ", const void *" buffer ", \
size_t " count ", unsigned long " flags ");"
.br
.BI "long rb_posix_write(struct rb *" rb ", int " fd ", \
size_t " count ");"
.br
.BI "long rb_posix_send(struct rb *" rb ", int " fd ", \
size_t " count ", unsigned long " flags ");"
.PP
Feature Test Macro:
.PP
.BR rb_posix_write (),
.BR rb_posix_send ():
.RS
ENABLE_POSIX_CALLS
.RE
.SH DESCRIPTION
.PP
.BR rb_write (3)
copies at most
.I count
.B elements
from
.I buffer
to
.I rb
buffer.
.PP
Note by
.B elements
we don't mean
.BR bytes.
For example if
.B object_size
is 4 bytes, and
.I count
is 3, this will copy 4 * 3 = 12 bytes from
.IR buffer .
Functions can and will try to commit as many bytes as possible in single burst,
so it is better to call these functions once with big
.I count
number instead of calling it in a loop with
.I count
== 1.
.PP
Altough
.I count
is of
.B size_t
type, functions will not write more than
.B LONG_MAX
elements.
If
.I count
is bigger than
.B LONG_MAX
it will be set to
.B LONG_MAX
internaly anyway.
Also make sure that formula
.IR count * rb->object_size
does not exceed
.B size_t
type or you will overflow internal integer and that will result in Undefined
Behaviour.
.PP
By default
.B rb
works in single-threaded mode.
In this mode all calls on
.B rb
object are non blocking.
This means if
.I count
.B elements
you want to write is higher than there is space left inside buffer, function
will copy only as much
.B elements
as there is space for inside
.B rb
and will immediately return.
If
.BR write (3)
is called when buffer is full,
.B EAGAIN
error will be returned.
.PP
If library has been built with
.B pthread
support, and
.I rb
was created with
.B O_MULTITHREAD
flag, all functions will be blocking calls by default.
That means, if you want to copy to
.I rb
more
.B elements
then there is space left, calling thread will be put to sleep - and thus will
use no CPU - until someone else calls
.BR rb_read (3)
to read data from buffer and makes some space.
.PP
.BR rb_posix_write (3)
works in the same way as
.BR rb_write (3)
but instead of copying data from
.I buffer
to
.I rb
object, it will copy data from whatever is associated with
.I fd
file descriptor
.I rb
object.
This may be ordinary file on disk, or pipe, or seria ldevice, or network socket.
This is convenient function that may be useful when you want to read same frame
from multiple sources - like allowing to control embedded device via serial,
network and fifo simultaneously.
You can create 3 threads that will read data
to
.I rb
and then one thread that will parse it.
This way you can get rid of polling each interface for data, which will speed
up execution - check example below.
.PP
It is valid for
.BR rb_posix_write (3)
to make early return with return value less than
.I count
elements.
This will happen when internal
.BR write ()
returns zero, which may mean we read end of the file, or remote computer closed
network connection.
.PP
When multiple threads access single
.I rb
object, in blocking way, it is guaranteed that each thread will write continous
data.
For example: consider 3 network server sockets, that receive static frames, each
containing 1024 bytes of data.
Now there is 1 thread for each network socket that reads from socket and puts
data into
.I rb
object - in parallel of course.
In such case
.B rb
guarantees that all data put this way into rb will be continous and no frame
corruption will occur.
But don't try this operation with
.B MSG_DONTWAIT
flag, as this may lead to situation when 1st thread will put into
.I rb
half of frame, then second thread will put its half frame, and then again
first thread will put second half of its frame - now frames are corrupted and
not really usable.
.PP
.BR rb_send (3)
and
.BR rb_posix_send (3)
work the same way as
.BR rb_write (3)
and
.BR rb_posix_write (3)
but also accept following
.IR flags :
.TP
.B MSG_DONTWAIT
Only works in multi threaded environment, on single threaded mode this is
default.
When passed and
.I rb
buffer contains less free
.B elements
than passed in
.IR count,
function will copy all
.B elements
from
.I buffer
into
.I rb
and will return immediately.
Not recommended when multiple concurent threads calls
.BR rb_write (3)
with this flag - may lead to interlaced reads.
.SH EXAMPLE
.PP
Reading frames from multiple sockets and parse them in one thread.
As usual, error handling ommited for clarity.
.EX
.PP
    struct tdata
    {
        struct rb *rb;
        int fd;
    };

    void *receiver(void *arg)
    {
        struct tdata *data = arg;

        for (;;)
        {
            /* rb_posix_write() will sleep current thread until
             * data shows up on data->fd file descriptor.
             *
             * NOTE: you should be carefull here, as calling this
             * function on slow data->fd will block other threads.
             * rb will try to call read() on data->fd and read()
             * will block until any data shows on data->fd, and
             * if data->fd is slow, this may take a long time.
             */

            if (rb_posix_write(data->rb, data->fd,
                    sizeof(struct data_frame) == -1)
            {
                if (errno == ECANCELED)
                {
                    /* rb_stop() has been called, rb shouldn't
                     * be used any more
                     */
                    break;
                }
            }
        }
    }

    void loop(struct rb *rb)
    {
        struct tdata tdata[3];
        pthread_t receivers[3];
        int i;

        tdata[0].rb = rb;
        tdata[0].fd = get_network_socket();

        tdata[1].rb = rb;
        tdata[1].fd = get_serial_socket();

        tdata[2].rb = rb;
        tdata[2].fd = get_fifo_socket();

        for (i = 0; i != 3; ++i)
        {
            /* create multiple threads that will read data from
             * sockets and put that data into rb. Pretty nice
             * way to eliminate polling, as these threads will
             * wake only when there is data available
             /

            pthread_create(&receivers[i], NULL, receiver, &tdata[i]);
        }

        for (;;)
        {
            /* receivers are started and will populate our rb with
             * frames over time, rb guarantees all frames here will
             * be valid (if they come valid from socket that is)
             */

            struct data_frame f;

            if (rb_read(rb, &f, sizeof(f)) == -1)
            {
                if (errno == ECANCELED)
                {
                    /* rb_stop() has been called, we shouldn't
                     * use rb object anymore
                     */

                    break;
                }
            }

            process_frame(&f);
        }

        for (i = 0; i != 3; ++i)
        {
            /* join all threads using rb object, so rb_destroy()
             * can be called safely
             */

            pthread_join(receivers[i], NULL);
        }
    }

.EE
.SH RETURN VALUES
.PP
On successfull write, function will return number of
.B elements
it stored in
.IR rb.
Returned value can be less than
.I count
if
.I rb
doesn't contain enough free space and function operates in non blocking mode.
In such case it is also ok for function to return 0 - meaning
.I rb
is full.
On errors function returns -1, in such case,
.I rb
buffer is left intact.
.SH ERRORS
.TP
.B EINVAL
Any of the passed pointers is NULL
.TP
.B EAGAIN
This error will be set, when
.I rb
is operating in non blocking mode, and there is no place in
.I rb
to write data from
.I buffer
immediately
.TP
.B ECANCELED
.BR rb_stop (3)
was called, and operation was cancelled, because
.I rb
object is abou to be destroyed.
You should not access
.I rb
object after you receive this error.
Otherwise you will probably get deadlock or application will crash.
Returned only if threads are enabled.
.TP
.B ENOSYS
Function is not implemented (was not compiled in).
.SH SEE ALSO
.PP
.BR rb_overview (7),
.BR rb_new (3),
.BR rb_init (3),
.BR rb_destroy (3),
.BR rb_cleanup (3),
.BR rb_discard (3),
.BR rb_stop (3),
.BR rb_stop_signal (3),
.BR rb_read (3),
.BR rb_recv (3),
.BR rb_posix_read (3),
.BR rb_posix_recv (3),
.BR rb_clear (3),
.BR rb_count (3),
.BR rb_space (3),
.BR rb_header_size (3),
.BR rb_array_size (3),
.BR rb_version (3)
