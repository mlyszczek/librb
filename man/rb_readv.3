'\" t
.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "RB_READV" "3" "Oct 31, 2025" "" "librb"
.SH NAME
.sp
\fI\%rb_read(3)\fP, \fI\%rb_recv(3)\fP, \fI\%rb_read_claim(3)\fP, \fI\%rb_read_commit(3)\fP, \fI\%rb_recv_claim(3)\fP,
\fI\%rb_recv_commit(3)\fP, \fI\%rb_read_commit_claim(3)\fP, \fI\%rb_recv_commit_claim(3)\fP,
\fI\%rb_readv(3)\fP, \fI\%rb_recvv(3)\fP \- read data from a ring buffer.
.SH SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.EX
#include <rb.h>

long rb_read(struct rb *rb, void *buffer, size_t count);
long rb_readv(struct rb *rb, const struct rb_iovec *vec, int iovcnt);
int rb_read_claim(struct rb *rb, void **buffer, size_t *count,
    size_t *object_size);
int rb_read_commit(struct rb *rb, size_t count);
int rb_read_commit_claim(struct rb *rb, void **buffer, size_t *count,
    size_t *object_size)

long rb_recv(struct rb *rb, void *buffer, size_t count, enum rb_flags flags);
long rb_recvv(struct rb *rb, const struct rb_iovec *vec, int iovcnt,
    enum rb_flags flags);
int rb_recv_claim(struct rb *rb, void **buffer, size_t *count,
    size_t *object_size, enum rb_flags flags);
int rb_recv_commit(struct rb *rb, size_t count, enum rb_flags flags);
int rb_recv_commit_claim(struct rb *rb, void **buffer, size_t *count,
    size_t *object_size, enum rb_flags flags);
.EE
.UNINDENT
.UNINDENT
.SH DESCRIPTION
.sp
\fI\%rb_read(3)\fP will read \fIcount\fP objects from \fIrb\fP buffer and copy them to \fIbuffer\fP\&.
\fIbuffer\fP must be big enough to hold \fIcount\fP elements of size that was configured
during \fIrb\fP initialization (via \fIobject_size\fP). Hence, \fIbuffer\fP should be at
least (\fIcount\fP * \fIrb\->object_size\fP) big. Function may read less elements than
requested if there was not enough data in \fIrb\fP\&. \fIcount\fP can be 0, in those
cases no data will be written, but function may still perform some check and
return errors.
.sp
If \fIrb\fP was created with \fBrb_dynamic\fP flag, function will always read a single
object from the \fIrb\fP\&. In that case \fIcount\fP tells how big, in bytes, \fIbuffer\fP is.
If \fIcount\fP is not big enough to hold whole frame, function will return error.
.sp
If \fIrb\fP is multi\-thread aware, and there is no data in \fIrb\fP, caller thread will
be blocked until someone writes to \fIrb\fP\&. Function still can read less than
requested number of elements, and will not block until all \fIcount\fP elements
is read. If at least 1 element is read until buffer gets empty, function will
not block. After successful read, function will wake potential thread blocked
at write operation.
.sp
\fI\%rb_recv(3)\fP behaves in the same way but also accepts \fIflags\fP to alter buffer
behavior for one single call. Possible flags are:
.TS
box center;
l|l.
T{
flag
T}	T{
description
T}
_
T{
rb_peek
T}	T{
Read data normally, but do not remove it from the \fIrb\fP buffer. When
that flag is passed, function will never block, and if there is no
data on the buffer, error will be returned.
T}
_
T{
rb_dontwait
T}	T{
Read data normally but do not block if buffer is empty. Instead return
error.
T}
.TE
.sp
\fI\%rb_readv(3)\fP instead of accepting single buffer, takes vector of buffers instead.
This is scatter \(dqinput\(dq. When \fIrb\fP is not dynamic, this is equivalent of just
calling \fI\%rb_read(3)\fP in a loop, one time for each buffer in \fIvec\fP vector. For
dynamic buffers, created with \fBrb_dynamic\fP flag, this will behave same as
if you passed single buffer with the size of all \fBvec[].len\fP, but data
instead of landing in a single buffer, will be scattered across buffers in
\fIvec\fP\&. This means that only single dynamic object will be taken from the
buffer. Last buffer can be larger than data in the \fIrb\fP buffer, in which
case all buffers will be filled in, and last buffer will have less bytes.
Function returns total number of bytes read, so you should do your own math
if that information matters to you. When function returns success, it is
guaranteed that single call will take single object from \fIrb\fP buffer and
scatter the data without interrupts \- in other words, reads are atomic.
.sp
\fI\%rb_recvv(3)\fP behaves the same but takes same flags as \fI\%rb_recv(3)\fP to alter per
call behavior.
.sp
\fI\%rb_read_claim(3)\fP doesn\(aqt read anything from the \fIrb\fP buffer, but instead gives
you all the information needed for you to perform the read. On successful
return, \fIbuffer\fP will be pointing at first readable byte, and you can read
starting at offset 0. \fIcount\fP will tell you how many elements you can read
from \fIbuffer\fP\&. If \fIrb\fP is close to memory wrap, you may get less data than
there is actually in the \fIrb\fP buffer. \fIobject_size\fP defines size in bytes of
a single object that can be read from \fIbuffer\fP\&.
.sp
If \fIrb\fP is multi\-thread aware, function will return with locked read mutex,
so no one else will be able to read from buffer until you call \fI\%rb_read_commit(3)\fP
and release mutex.
.sp
\fI\%rb_read_commit(3)\fP must be called after \fI\%rb_read_claim(3)\fP with \fIcount\fP being
number of elements (not bytes) you read from the \fIbuffer\fP\&. If \fIrb\fP is
multi\-thread aware, this will also wake up thread blocked in write operation.
.sp
\fI\%rb_read_commit_claim(3)\fP can be used to commit data to ring buffer as you would
do with \fI\%rb_read_commit(3)\fP, but also immediately claims new buffer as you would
do with \fI\%rb_read_claim(3)\fP\&. Benefit of calling this function is that you can get
new buffer without releasing the lock. This may be useful when you must perform
multiple reads from buffer while making sure no one else disturbs you in the
middle.
.sp
Function takes same parameters as \fI\%rb_read_claim(3)\fP but \fIcount\fP is both
input and output. As input arguments is defines how many bytes you commit
to the buffer, same calling \fI\%rb_read_commit(3)\fP\&. As output it defines size of
returned \fIbuffer\fP as with \fI\%rb_read_claim(3)\fP\&.
.SH RETURN VALUE
.sp
\fI\%rb_read(3)\fP, \fI\%rb_recv(3)\fP, \fI\%rb_readv(3)\fP and \fI\%rb_recvv(3)\fP will return number of
elements actually read from ring buffer. \fI\%rb_read_commit(3)\fP, \fI\%rb_read_claim(3)\fP,
\fI\%rb_recv_commit(3)\fP, \fI\%rb_recv_claim(3)\fP, \fI\%rb_read_commit_claim(3)\fP and
\fI\%rb_recv_commit_claim(3)\fP return 0 on success.
.sp
All functions will return \-1 on errors with \fIerrno\fP variable set that will
describe an error. If error is returned no data is removed from the buffer.
.SH ERRORS
.sp
All functions may return one of these on error
.INDENT 0.0
.TP
.B EINVAL
Any of the input parameter is invalid
.TP
.B EAGAIN
Ring buffer is empty and function returned without reading anything.
.UNINDENT
.sp
When \fIrb\fP was created with \fBrb_dynamic\fP, these additional errors may appear
.INDENT 0.0
.TP
.B ENOBUFS
Data is available on the buffer, but passed \fIbuffer\fP is not big enough
to hold whole message.
.UNINDENT
.sp
When \fIrb\fP is multi\-thread aware, these additional error may appear
.INDENT 0.0
.TP
.B EAGAIN
\fIrb\fP was created with \fBrb_growable\fP while being thread\-aware and ring
buffer is in process of increasing size. Read notes in \fI\%rb_write(3)\fP man page.
.TP
.B ECANCELED
Other thread called \fI\%rb_stop(3)\fP and no data has been read.
.UNINDENT
.SH EXAMPLES
.sp
Note that these examples do not have error handling for simplicity.
.sp
Simple read. Assuming ring buffer holds simple integers.
.INDENT 0.0
.INDENT 3.5
.sp
.EX
int rd_buf[128];
long nread;

nread = rb_read(rb, rd_buf, sizeof(rd_buf));
.EE
.UNINDENT
.UNINDENT
.sp
Read but force non blocking operation
.INDENT 0.0
.INDENT 3.5
.sp
.EX
int rd_buf[128];
long nread;

nread = rb_recv(rb, rd_buf, sizeof(rd_buf), rb_dontwait);
.EE
.UNINDENT
.UNINDENT
.sp
Claim buffer, and send data over serial line. Thanks to claim/commit we don\(aqt
have to create any intermediate buffer and do double copying.
.INDENT 0.0
.INDENT 3.5
.sp
.EX
long nwritten;
void *buffer;
size_t count, object_size;

rb_read_claim(rb, &buffer, &count, &object_size, 0);
nwritten = write(serial_fd, buffer, count * object_size);
/* tell rb, how many bytes we actually used, write() may return
 * less than we asked it to send */
rb_read_commit(rb, nwritten / object_size);
.EE
.UNINDENT
.UNINDENT
.sp
Perform scatter read on dynamic ring buffer
.INDENT 0.0
.INDENT 3.5
.sp
.EX
char str[] = \(dqtest\e0data\e0to\e0read\en\e0\(dq;
char a[5], b[5], c[3], d[16];
struct rb_iovec iov[] = {
    { .base = a, .len = sizeof(a) },
    { .base = b, .len = sizeof(b) },
    { .base = c, .len = sizeof(c) },
    { .base = d, .len = sizeof(d) },
 };

 rb_write(rb, str, sizeof(str));
 rb_readv(rb, iov, rb_array_size(iov));
 printf(\(dq%s %s %s %s\(dq, a, b, c, d);
 /* will print \(dqtest data to read\(dq */
.EE
.UNINDENT
.UNINDENT
.SH SEE ALSO
.sp
\fI\%rb_new(3)\fP, \fI\%rb_init(3)\fP, \fI\%rb_destroy(3)\fP, \fI\%rb_cleanup(3)\fP, \fI\%rb_write(3)\fP, \fI\%rb_send(3)\fP,
\fI\%rb_writev(3)\fP, \fI\%rb_sendv(3)\fP, \fI\%rb_read(3)\fP, \fI\%rb_recv(3)\fP, \fI\%rb_readv(3)\fP, \fI\%rb_recvv(3)\fP,
\fI\%rb_read_claim(3)\fP, \fI\%rb_read_commit(3)\fP, \fI\%rb_write_claim(3)\fP, \fI\%rb_write_commit(3)\fP,
\fI\%rb_clear(3)\fP, \fI\%rb_discard(3)\fP, \fI\%rb_count(3)\fP, \fI\%rb_space(3)\fP, \fI\%rb_stop(3)\fP,
\fI\%rb_peek_size(3)\fP, \fI\%rb_set_hard_max_count(3)\fP
.SH AUTHOR
Michał Łyszczek <michal.lyszczek@bofc.pl>
.SH COPYRIGHT
2025, Michał Łyszczek
.\" Generated by docutils manpage writer.
.
