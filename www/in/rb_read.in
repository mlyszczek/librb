NAME
----
**rb_read**, **rb_recv**, **rb_read_claim**, **rb_read_commit** - read data from
a ring buffer.

SYNOPSIS
--------
.. code-block:: c

   #include <rb.h>

   long rb_read(struct rb *rb, void *buffer, size_t count);
   long rb_recv(struct rb *rb, void *buffer, size_t count, enum rb_flags flags);
   long rb_read_claim(struct rb *rb, void **buffer, size_t *count,
       size_t *object_size, enum rb_flags flags);
   long rb_read_commit(struct rb *rb, size_t count);

DESCRIPTION
-----------
|rb_read| will read *count* objects from *rb* buffer and copy them to *buffer*.
*buffer* must be big enough to hold *count* elements of size that was configured
during *rb* initialization (via *object_size*). Hence, *buffer* should be at
least (*count* * *rb->object_size*) big. Function may read less elements than
requested if there was not enough data in *rb*. *count* can be 0, in those
cases no data will be written, but function may still perform some check and
return errors.

If *rb* was created with **rb_dynamic** flag, function will always read a single
object from the *rb*. In that case *count* tells how big, in bytes, *buffer* is.
If *count* is not big enough to hold whole frame, function will return error.

If *rb* is multi-thread aware, and there is no data in *rb*, caller thread will
be blocked until someone writes to *rb*. Function still can read less than
requested number of elements, and will not block until all *count* elements
is read. If at least 1 element is read until buffer gets empty, function will
not block. After successful read, function will wake potential thread blocked
at write operation.

|rb_recv| behaves in the same way but also accepts *flags* to alter buffer
behavior for one single call. Possible flags are:

.. list-table::
    :header-rows: 1

    * - flag
      - description
    * - rb_peek
      - Read data normally, but do not remove it from the *rb* buffer. When
        that flag is passed, function will never block, and if there is no
        data on the buffer, error will be returned.
    * - rb_dontwait
      - Read data normally but do not block if buffer is empty. Instead return
        error.

|rb_read_claim| doesn't read anything from the *rb* buffer, but instead gives
you all the information needed for you to perform the read. On successful
return, *buffer* will be pointing at first readable byte, and you can read
starting at offset 0. *count* will tell you how many elements you can read
from *buffer*. If *rb* is close to memory wrap, you may get less data than
there is actually in the *rb* buffer. *object_size* defines size in bytes of
a single object that can be read from *buffer*.

If *rb* is multi-thread aware, function will return with locked read mutex,
so no one else will be able to read from buffer until you call |rb_read_commit|
and release mutex.

*flags* argument accepts only *rb_dontwait* flag (only in multi-thread mode).

|rb_read_commit| must be called after |rb_read_claim| with *count* being
number of elements (not bytes) you read from the *buffer*. If *rb* is
multi-thread aware, this will also wake up thread blocked in write operation.

RETURN VALUE
------------
|rb_read| and |rb_recv| will return number of elements actually read from
ring buffer. |rb_read_commit| and |rb_read_claim| return 0 on success.

All functions will return -1 on errors with *errno* variable set that will
describe an error. If error is returned no data is removed from the buffer.

ERRORS
------
All functions may return one of these on error

EINVAL
    Any of the input parameter is invalid

EAGAIN
    Ring buffer is empty and function returned without reading anything. 

When *rb* was created with **rb_dynamic**, these additional errors may appear

ENOBUFS
    Data is available on the buffer, but passed *buffer* is not big enough
    to hold whole message.

When *rb* is multi-thread aware, these additional error may appear

EAGAIN
    *rb* was created with **rb_growable** while being thread-aware and ring
    buffer is in process of increasing size. Read notes in |rb_write| man page.

ECANCELED
    Other thread called |rb_stop| and no data has been read.

EXAMPLES
--------
Note that these examples do not have error handling for simplicity.

Simple read. Assuming ring buffer holds simple integers.

.. code-block:: c

   int rd_buf[128];
   long nread;

   nread = rb_read(rb, rd_buf, sizeof(rd_buf));

Read but force non blocking operation

.. code-block:: c

   int rd_buf[128];
   long nread;

   nread = rb_recv(rb, rd_buf, sizeof(rd_buf), rb_dontwait);

Claim buffer, and send data over serial line. Thanks to claim/commit we don't
have to create any intermediate buffer and do double copying.

.. code-block:: c

   long nwritten;
   void *buffer;
   size_t count, object_size;

   rb_read_claim(rb, &buffer, &count, &object_size, 0);
   nwritten = write(serial_fd, buffer, count * object_size);
   /* tell rb, how many bytes we actually used, write() may return
    * less than we asked it to send */
   rb_read_commit(rb, nwritten / object_size);

.. include:: /in/footer.in
